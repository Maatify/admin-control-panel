// FILE: Modules/Exceptions/Exception/MaatifyException.php
<?php

declare(strict_types=1);

namespace Maatify\Exceptions\Exception;

use LogicException;
use Maatify\Exceptions\Contracts\ApiAwareExceptionInterface;
use Maatify\Exceptions\Contracts\ErrorCategoryInterface;
use Maatify\Exceptions\Contracts\ErrorCodeInterface;
use Maatify\Exceptions\Contracts\ErrorPolicyInterface;
use Maatify\Exceptions\Contracts\EscalationPolicyInterface;
use Maatify\Exceptions\Policy\DefaultErrorPolicy;
use Maatify\Exceptions\Policy\DefaultEscalationPolicy;
use RuntimeException;
use Throwable;

/**
 * Base exception for all Maatify exceptions.
 *
 * - Policy-driven validation
 * - Escalation fully injectable
 * - No enum coupling
 * - Extensible & reusable
 * - Supports global default policy overrides
 */
abstract class MaatifyException extends RuntimeException implements ApiAwareExceptionInterface
{
    /** @var array<string, mixed> */
    private array $meta = [];

    private ErrorPolicyInterface $policy;
    private EscalationPolicyInterface $escalationPolicy;

    private ?ErrorCodeInterface $errorCodeOverride = null;
    private ?int $httpStatusOverride = null;
    private ?bool $isSafeOverride = null;
    private ?bool $isRetryableOverride = null;

    private ?ErrorCategoryInterface $escalatedCategory = null;
    private ?int $escalatedHttpStatus = null;

    // ---------------------------------------------------------------------
    // Global Policy Overrides (Optional)
    // ---------------------------------------------------------------------

    private static ?ErrorPolicyInterface $globalPolicy = null;
    private static ?EscalationPolicyInterface $globalEscalationPolicy = null;

    /**
     * Override default policy globally for all new exceptions.
     */
    public static function setGlobalPolicy(
        ErrorPolicyInterface $policy
    ): void {
        self::$globalPolicy = $policy;
    }

    /**
     * Override default escalation policy globally.
     */
    public static function setGlobalEscalationPolicy(
        EscalationPolicyInterface $policy
    ): void {
        self::$globalEscalationPolicy = $policy;
    }

    /**
     * Reset global policies to defaults.
     */
    public static function resetGlobalPolicies(): void
    {
        self::$globalPolicy = null;
        self::$globalEscalationPolicy = null;
    }

    /**
     * @param array<string, mixed> $meta
     *
     * WARNING:
     * Global policies are process-wide.
     * In long-running environments (Swoole, RoadRunner),
     * ensure policies are set during bootstrap only.
     */
    public function __construct(
        string $message = '',
        int $code = 0,
        ?Throwable $previous = null,
        ?ErrorCodeInterface $errorCodeOverride = null,
        ?int $httpStatusOverride = null,
        ?bool $isSafeOverride = null,
        ?bool $isRetryableOverride = null,
        array $meta = [],
        ?ErrorPolicyInterface $policy = null,
        ?EscalationPolicyInterface $escalationPolicy = null,
    ) {
        parent::__construct($message, $code, $previous);

        $this->policy = $policy
                        ?? self::$globalPolicy
                           ?? DefaultErrorPolicy::default();

        $this->escalationPolicy = $escalationPolicy
                                  ?? self::$globalEscalationPolicy
                                     ?? DefaultEscalationPolicy::default();

        $this->errorCodeOverride = $errorCodeOverride;
        $this->httpStatusOverride = $httpStatusOverride;
        $this->isSafeOverride = $isSafeOverride;
        $this->isRetryableOverride = $isRetryableOverride;
        $this->meta = $meta;

        $this->validateErrorCodeOverride();
        $this->validateHttpStatusOverride();
        $this->calculateEscalation($previous);
    }

    // ---------------------------------------------------------------------
    // Validation
    // ---------------------------------------------------------------------

    private function validateErrorCodeOverride(): void
    {
        if ($this->errorCodeOverride === null) {
            return;
        }

        $this->policy->validate(
            $this->errorCodeOverride,
            $this->defaultCategory()
        );
    }

    private function validateHttpStatusOverride(): void
    {
        if ($this->httpStatusOverride === null) {
            return;
        }

        $default = $this->defaultHttpStatus();

        if (intdiv($this->httpStatusOverride, 100) !== intdiv($default, 100)) {
            throw new LogicException(sprintf(
                'HttpStatus override %d must belong to same class family as default %d',
                $this->httpStatusOverride,
                $default
            ));
        }
    }

    // ---------------------------------------------------------------------
    // Escalation
    // ---------------------------------------------------------------------

    private function calculateEscalation(?Throwable $previous): void
    {
        if (!($previous instanceof ApiAwareExceptionInterface)) {
            return;
        }

        $currentCategory = $this->defaultCategory();
        $previousCategory = $previous->getCategory();

        $this->escalatedCategory =
            $this->escalationPolicy->escalateCategory(
                $currentCategory,
                $previousCategory,
                $this->policy
            );

        $currentStatus = $this->httpStatusOverride ?? $this->defaultHttpStatus();
        $previousStatus = $previous->getHttpStatus();

        $this->escalatedHttpStatus =
            $this->escalationPolicy->escalateHttpStatus(
                $currentStatus,
                $previousStatus
            );
    }

    // ---------------------------------------------------------------------
    // Default behavior (subclasses MUST define core identity)
    // ---------------------------------------------------------------------

    abstract protected function defaultErrorCode(): ErrorCodeInterface;

    abstract protected function defaultCategory(): ErrorCategoryInterface;

    abstract protected function defaultHttpStatus(): int;

    protected function defaultIsSafe(): bool
    {
        return false;
    }

    protected function defaultIsRetryable(): bool
    {
        return false;
    }

    // ---------------------------------------------------------------------
    // Final API Contract Methods
    // ---------------------------------------------------------------------

    final public function getErrorCode(): ErrorCodeInterface
    {
        return $this->errorCodeOverride ?? $this->defaultErrorCode();
    }

    final public function getCategory(): ErrorCategoryInterface
    {
        return $this->escalatedCategory ?? $this->defaultCategory();
    }

    final public function getHttpStatus(): int
    {
        return $this->escalatedHttpStatus
               ?? $this->httpStatusOverride
                  ?? $this->defaultHttpStatus();
    }

    final public function isSafe(): bool
    {
        return $this->isSafeOverride ?? $this->defaultIsSafe();
    }

    final public function isRetryable(): bool
    {
        return $this->isRetryableOverride ?? $this->defaultIsRetryable();
    }

    /**
     * @return array<string, mixed>
     */
    final public function getMeta(): array
    {
        return $this->meta;
    }
}



// FILE: Modules/Exceptions/Contracts/ApiAwareExceptionInterface.php
<?php

declare(strict_types=1);

namespace Maatify\Exceptions\Contracts;

use Throwable;

interface ApiAwareExceptionInterface extends Throwable
{
    public function getHttpStatus(): int;

    public function getErrorCode(): ErrorCodeInterface;

    public function getCategory(): ErrorCategoryInterface;

    public function isSafe(): bool;

    /**
     * @return array<string, mixed>
     */
    public function getMeta(): array;

    public function isRetryable(): bool;
}



// FILE: Modules/Exceptions/Contracts/ErrorPolicyInterface.php
<?php

declare(strict_types=1);

namespace Maatify\Exceptions\Contracts;

interface ErrorPolicyInterface
{
    public function validate(
        ErrorCodeInterface $code,
        ErrorCategoryInterface $category
    ): void;

    public function severity(
        ErrorCategoryInterface $category
    ): int;
}




// FILE: Modules/Exceptions/Contracts/EscalationPolicyInterface.php
<?php

declare(strict_types=1);

namespace Maatify\Exceptions\Contracts;

interface EscalationPolicyInterface
{
    public function escalateCategory(
        ErrorCategoryInterface $current,
        ErrorCategoryInterface $previous,
        ErrorPolicyInterface $policy
    ): ErrorCategoryInterface;

    public function escalateHttpStatus(
        int $currentStatus,
        int $previousStatus
    ): int;
}




// FILE: Modules/Exceptions/Policy/DefaultErrorPolicy.php
<?php

declare(strict_types=1);

namespace Maatify\Exceptions\Policy;

use LogicException;
use Maatify\Exceptions\Contracts\ErrorCategoryInterface;
use Maatify\Exceptions\Contracts\ErrorCodeInterface;
use Maatify\Exceptions\Contracts\ErrorPolicyInterface;

/**
 * Configurable default policy.
 *
 * - Provides sane defaults
 * - Can be fully overridden
 * - Immutable after construction
 */
final class DefaultErrorPolicy implements ErrorPolicyInterface
{

    /** @var array<string,int> */
    private array $severityRanking;

    /** @var array<string, list<string>> */
    private array $allowedErrorCodes;

    /**
     * @param array<string,int> $severityRanking
     * @param   array<string,list<string>>  $allowedErrorCodes
     */
    public function __construct(
        array $severityRanking,
        array $allowedErrorCodes
    ) {
        $this->severityRanking = $severityRanking;
        $this->allowedErrorCodes = $allowedErrorCodes;
    }

    /**
     * Returns default immutable policy instance.
     */
    public static function default(): self
    {
        return new self(
            self::defaultSeverityRanking(),
            self::defaultAllowedCodes()
        );
    }

    /**
     * Create policy with partial overrides.
     *
     * @param array<string,int> $severityOverrides
     * @param array<string,array<string>> $allowedOverrides
     */
    public static function withOverrides(
        array $severityOverrides = [],
        array $allowedOverrides = []
    ): self {
        return new self(
            array_replace(self::defaultSeverityRanking(), $severityOverrides),
            array_replace_recursive(self::defaultAllowedCodes(), $allowedOverrides)
        );
    }

    // -----------------------------------------------------

    public function validate(
        ErrorCodeInterface $code,
        ErrorCategoryInterface $category
    ): void {
        $categoryId = $category->getValue();
        $codeId = $code->getValue();

        // Category not configured → allow
        if (!isset($this->allowedErrorCodes[$categoryId])) {
            return;
        }

        // Category configured but no restriction → allow
        if ($this->allowedErrorCodes[$categoryId] === []) {
            return;
        }

        if (!in_array($codeId, $this->allowedErrorCodes[$categoryId], true)) {
            throw new LogicException(
                sprintf(
                    'Error code "%s" is not allowed for category "%s".',
                    $codeId,
                    $categoryId
                )
            );
        }
    }

    public function severity(
        ErrorCategoryInterface $category
    ): int {
        return $this->severityRanking[$category->getValue()] ?? 0;
    }

    // -----------------------------------------------------
    // Default Config Definitions
    // -----------------------------------------------------

    /**
     * @return array<string,int>
     */
    private static function defaultSeverityRanking(): array
    {
        return [
            'SYSTEM' => 90,
            'RATE_LIMIT' => 80,
            'AUTHENTICATION' => 70,
            'AUTHORIZATION' => 60,
            'VALIDATION' => 50,
            'BUSINESS_RULE' => 40,
            'CONFLICT' => 30,
            'NOT_FOUND' => 20,
            'UNSUPPORTED' => 10,
            'SECURITY' => 85
        ];
    }

    /**
     * @return array<string,list<string>>
     */
    private static function defaultAllowedCodes(): array
    {
        return [
            'VALIDATION' => ['INVALID_ARGUMENT'],
            'AUTHENTICATION' => [
                'UNAUTHORIZED',
                'SESSION_EXPIRED',
                'AUTH_STATE_VIOLATION',
                'RECOVERY_LOCKED',
            ],
            'AUTHORIZATION' => ['FORBIDDEN'],
            'CONFLICT' => ['CONFLICT', 'ENTITY_IN_USE'],
            'NOT_FOUND' => ['RESOURCE_NOT_FOUND'],
            'BUSINESS_RULE' => ['BUSINESS_RULE_VIOLATION'],
            'UNSUPPORTED' => ['UNSUPPORTED_OPERATION'],
            'SYSTEM' => ['MAATIFY_ERROR', 'DATABASE_CONNECTION_FAILED'],
            'RATE_LIMIT' => ['TOO_MANY_REQUESTS'],
            'SECURITY' => []
        ];
    }
}



// FILE: Modules/Exceptions/Policy/DefaultEscalationPolicy.php
<?php

declare(strict_types=1);

namespace Maatify\Exceptions\Policy;


use Maatify\Exceptions\Contracts\ErrorCategoryInterface;
use Maatify\Exceptions\Contracts\EscalationPolicyInterface;
use Maatify\Exceptions\Contracts\ErrorPolicyInterface;

final class DefaultEscalationPolicy implements EscalationPolicyInterface
{
    private function __construct()
    {
    }

    public static function default(): self
    {
        return new self();
    }

    public function escalateCategory(
        ErrorCategoryInterface $current,
        ErrorCategoryInterface $previous,
        ErrorPolicyInterface $policy
    ): ErrorCategoryInterface {
        $currentSeverity = $policy->severity($current);
        $previousSeverity = $policy->severity($previous);

        return $previousSeverity > $currentSeverity
            ? $previous
            : $current;
    }

    public function escalateHttpStatus(
        int $currentStatus,
        int $previousStatus
    ): int {
        return max($previousStatus, $currentStatus);
    }
}



// FILE: Modules/ContentDocuments/Domain/Exception/InvalidDocumentVersionException.php
<?php

declare(strict_types=1);

namespace Maatify\ContentDocuments\Domain\Exception;

use Maatify\ContentDocuments\Domain\Enum\ContentDocumentsErrorCodeEnum;
use Maatify\Exceptions\Contracts\ErrorCodeInterface;

final class InvalidDocumentVersionException extends ContentDocumentsInvalidArgumentException
{
    protected function defaultErrorCode(): ErrorCodeInterface
    {
        return ContentDocumentsErrorCodeEnum::INVALID_DOCUMENT_VERSION;
    }
}



// CONFIRMATION
// Does MaatifyException contain HTTP status logic? YES
// Does it contain JSON serialization logic? NO
// Does it contain response-building logic? NO
